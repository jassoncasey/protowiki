def ofp : namespace {

def Version : type = enum(nat(8)) {
  OFP_1_0 = 1
}

def v1_0 : namespace {

def Type : type = enum(nat(8)) {
  HELLO = 0, ERROR = 1, ECHO_REQ = 2, ECHO_RES = 3, VENDOR = 4,
  FEATURE_REQ = 5, FEATURE_RES = 6, GET_CONFIG_REQ = 7, GET_CONFIG_RES = 8,
  SET_CONFIG = 9, PACKET_IN = 10, FLOW_REMOVED = 11, PORT_STATUS = 12,
  PACKET_OUT = 13, FLOW_MOD = 14, PORT_MOD = 15,
  STATS_REQ = 16, STATS_RES = 17, BARRIER_REQ = 18, BARRIER_RES = 19,
  QUEUE_GET_CONFIG_REQ = 20, QUEUE_GET_CONFIG_RES = 21
}

def Hello : type = record {
  data : vector(nat(8));
}

ErrorType : type = enum(nat(16,msbf)) {
  HELLO_FAILED    : HelloFailedCode;
  BAD_REQUEST     : BadRequestCode;
  BAD_ACTION      : BadActionCode;
  FLOW_MOD_FAILED : FlowModFailedCode;
  PORT_MOD_FAILED : PortModFailedCode;
  QUEUE_OP_FAILED : QueueOpFailedCode;
}

HelloFailedCode : type = enum(nat(16,msbf)) {
  INCOMPATIBLE = 0,
  EPERM        = 1  
}

BadRequestCode : type = enum(nat(16,msbf)) {
  BAD_VERSION    = 0,
  BAD_TYPE       = 1,
  BAD_STAT       = 2,
  BAD_VENDOR     = 3,
  BAD_SUB_TYPE   = 4,
  EPERM          = 5,
  BAD_LENGTH     = 6,
  BUFFER_EMPTY   = 7,
  BUFFER_UNKNOWN = 8
}

BadActionCode : type = enum(nat(16,msbf)) {
  BAD_TYPE        = 0,
  BAD_LENGTH      = 1,
  BAD_VENDOR      = 2,
  BAD_VENDOR_TYPE = 3,
  BAD_OUT_PORT    = 4,
  BAD_ARGUMENT    = 5,
  EPERM           = 6,
  TOO_MANY        = 7,
  BAD_QUEUE       = 8
}

FlowModFailedCode : type = enum(nat(16,msbf)) {
  ALL_TABLES_FULL   = 0,
  OVERLAP           = 1,
  EPERM             = 2,
  BAD_EMERG_TIMEOUT = 3,
  BAD_COMMAND       = 4,
  UNSUPPORTED       = 5
}

PortModFailedCode : type = enum(nat(16,msbf)) {
  BAD_PORT    = 0,
  BAD_HW_ADDR = 1
}

QueueOpFailedCode : type = enum(nat(16,msbf)) {
  BAD_PORT  = 0,
  BAD_QUEUE = 1,
  EPERM     = 2
}

def ErrorCode(t:ErrorType):type = variant {
  HelloFailedCode   if t == HELLO_FAILED;
  BadRequestCode    if t == BAD_REQUEST;
  BadActionCode     if t == BAD_ACTION;
  FlowModFailedCode if t == FLOW_MOD_FAILED;
  PortModFailedCode if t == PORT_MOD_FAILED;
  QueueOpFailedCode if t == QUEUE_OP_FAILED;
}

def Error : type = record {
  type : ErrorType;
  code : ErrorCode;
}

def EchoReq : type = record {
  data : vector(nat(8));
}

def EchoRes : type = record {
  data : vector(nat(8));
}

def Vendor : type = record {
  id : nat(32,msbf);
  data : vector(nat(8));
}

def FeatureReq : type = record {}

def FeatureCapabilities : type = enum(nat(32,msbf)) {
  0..255,
  FLOW_STATS   = 1,
  TABLE_STATS  = 2,
  PORT_STATS   = 4,
  STP          = 8,
  RESERVED     = 16,
  IP_REASM     = 32,
  QUEUE_STATS  = 64,
  ARP_MATCH_IP = 128
}

def FeatureActions : type = enum(nat(32,msbf)) {
  0..4095,
  OUTPUT       = 1,
  SET_VLAN_VID = 2,
  SET_VLAN_PCP = 4,
  STRIP_VLAN   = 8,
  SET_DL_SRC   = 16,
  SET_DL_DST   = 32,
  SET_NW_SRC   = 64,
  SET_NW_DST   = 128,
  SET_NW_TOS   = 256,
  SET_TP_SRC   = 512,
  SET_TP_DST   = 1024,
  ENQUEUE      = 2048
}

def Port_Id : type = enum(nat(16,msbf)) {
  0..65279
  MAX        = 65280,
  IN_PORT    = 65528,
  TABLE      = 65529,
  NORMAL     = 65530,
  FLOOD      = 65531,
  ALL        = 65532,
  CONTROLLER = 65533,
  LOCAL      = 65534,
  NONE       = 65535
}

def PortConfig : type = enum(nat(32,msbf)) {
  0..127,
  PORT_DOWN	  = 1,
  NO_STP      = 2,
  NO_RECV     = 4,
  NO_RECV_STP = 8,
  NO_FLOOD    = 16,
  NO_FWD      = 32,
  NO_PACKETIN = 64
}

def PortState : type = enum(nat(32,msbf)) {
  0..31,
  STP_LISTEN  = 0,
  LINK_DOWN   = 1,
  STP_LEARN   = 2,
  STP_FORWARD = 4,
  STP_BLOCK   = 8,
  STP_MASK    = 16
}

def PortFeature : type = enum(nat(32,msbf)) {
  0..4095,
  10MB_HD    = 1,
  10MB_FD    = 2,
  100MD_HD   = 4,
  100MD_FD   = 8,
  1GB_HD     = 16,
  1GB_FD     = 32,
  10GB_FD    = 64,
  COPPER     = 128,
  FIBER      = 256,
  AUTO_NEG   = 512,
  PAUSE      = 1024,
  PAUSE_ASYM = 2048
}

def Port : type = record {
  port_id    : Port_id;
  hw_addr    : nat(48,msbf);
  name       : nat(128,msbf);
  config     : PortConfig;
  state      : PortState;
  curr       : PortFeature;
  advertised : PortFeature;
}

def FeatureRes : type = record {
  datapath-id  : nat(64,msbf);
  n_buffers    : nat(32,msbf);
  n_tables     : nat(8);
               : nat(24);
  capabilities : FeatureCapabilities;
  actions      : FeatureActions;
  ports        : vector(Port);
}

def GetConfigReq : type = record {}

def ConfigFlags : type = enum(nat(16,msbf)) {
  FRAG_NORMAL = 0,
  FRAG_DROP   = 1,
  FRAG_REASM  = 2,
  FRAG_MASK   = 3
}

def GetConfigRes : type = record {
  flags         : ConfigFlags;
  miss_send_len : nat(16,msbf);
}

def SetConfig : type = record {
  flags         : ConfigFlags;
  miss_send_len : nat(16,msbf);
}

def PacketInReason : type = enum(nat(8)) {
  NO_MACTH = 0,
  ACTION   = 1
}

def PacketIn : type = record {
  buffer_id : nat(32,msbf);
  total_len : nat(16,msbf);
  in_port   : nat(16,msbf);
  reason    : PacketInReason;
            : nat(8);
  data      : vector(nat(8));
}

def MatchWildcards : type = enum(nat(32,msbf)) {
  0..4194303,
  IN_PORT     = 1, 
  DL_VLAN     = 2, 
  DL_SRC      = 4,
  DL_DST      = 8,
  DL_TYPE     = 16,
  NW_PROT     = 32,
  TP_SRC      = 64,
  TP_DST      = 128,
  NW_SRC      = 0 | 2^(40 - subnet_length),
  NW_DST      = 0 | 2^(46 - subnet_length),
  DL_VLAN_PCP = 1048576,
  NW_TOS      = 2097152,
  ALL         = 4194303
}

def MatchInPort : type = enum(nat(16, msbf)) {
  0..65279
}

def Match : type = record {
  wildcards : MatchWildcards;
  in_port   : MatchInPort;
  dl_src    : nat(48,msbf); 
  dl_dst    : nat(48,msbf);  
  dl_vlan   : nat(16,msbf);  
  dl_pcp    : nat(16,msbf);  
            : nat(8);
  dl_type   : nat(16,msbf); 
  nw_tos    : nat(8);
  nw_proto  : nat(8);  
            : nat(16);
  nw_src    : nat(32,msbf); 
  nw_dst    : nat(32,msbf); 
  tp_src    : nat(16,msbf); 
  tp_dst    : nat(16,msbf); 
}

def FlowRemovedReason : type = enum(nat(8)) {
  IDLE_TIMEOUT = 0,
  HARD_TIMEOUT = 1,
  DELETE       = 2
}

def FlowRemoved : type = record {
  match         : Match;
  cookie        : nat(64,msbf); 
  reason    	: FlowRemovedReason;
                : pad(8);
  priority      : nat(16,msbf);
  duration_sec  : nat(32,msbf); 
  duration_nsec : nat(32,msbf);   
  idle_timeout  : nat(16,msbf);
                : pad(16);
  packet_count  : nat(64,msbf); 
  byte_count    : nat(64,msbf); 
}

def PortStatusReason : type = enum(nat(8)) {
  ADD 	 = 0,
  DELETE = 1,
  MODIFY = 2
}

def PortStatus : type = record {
  reason : PortStatusReason;
         : pad(56);  
  port   : Port		 
}

def ActionType : type = enum(nat(16,msbf)) {
  OUTPUT       = 0,
  SET_VLAN_VID = 1,
  SET_VLAN_PCP = 2,
  STRIP_VLAN   = 3,
  SET_DL_SRC   = 4,
  SET_DL_DST   = 5,
  SET_NW_SRC   = 6,
  SET_NW_DST   = 7,
  SET_NW_TOS   = 8,
  SET_TP_SRC   = 9,
  SET_TP_DST   = 10,
  ENQUEUE      = 11,
  VENDOR       = 65535
}

def ActionOutput : type = record {
  port    : Port_id;
  max_len : nat(16,msbf);
}

def ActionSetVlanVid : type = record {
  vlan_vid : nat(16,msbf);
           : nat(16,msbf);
}

def ActionSetVlanPcp : type = record {
  vlan_pcp : nat(16,msbf);
           : nat(16,msbf);
}

def ActionStripVlan : type = record {}

def ActionSetDlSrc : type = record {
  set_dl_src : nat(48,msbf);
             : nat(48,msbf);
}

def ActionSetDlDst : type = record {
  set_dl_dst : nat(48,msbf);
             : nat(48,msbf);
}

def ActionSetNwSrc : type = record {
  set_nw_src : nat(32,msbf);
}

def ActionSetNwDst : type = record {
  set_nw_dst : nat(32,msbf);
}

def ActionSetNwTos : type = record {
  set_nw_tos : nat(8);
             : nat(24,msbf);
}

def ActionSetTpSrc : type = record {
  set_dl_src : nat(16,msbf);
             : nat(16,msbf);
}

def ActionSetTpDst : type = record {
  set_dl_dst : nat(16,msbf);
             : nat(16,msbf);
}

def ActionEnqueue : type = record {
  port     : Port_id;
           : nat(48,msbf);
  queue_id : nat(32,msbf);
}

def ActionVendor : type = record {
  vendor : nat(32,msbf);
}

def ActionPayload(t:ActionType):type = variant {
  ActionOutput     if t == OUTPUT;
  ActionSetVlanVid if t == SET_VLAN_VID;
  ActionSetVlanPcp if t == SET_VLAN_PCP;
  ActionStripVlan  if t == STRIP_VLAN;
  ActionSetDlSrc   if t == SET_DL_SRC;
  ActionSetDlDst   if t == SET_DL_DST;
  ActionSetNwSrc   if t == SET_NW_SRC;
  ActionSetNwDst   if t == SET_NW_DST;
  ActionSetNwTos   if t == SET_NW_TOS;
  ActionSetTpSrc   if t == SET_TP_SRC;
  ActionSetTpDst   if t == SET_TP_DST;
  ActionEnqueue    if t == ENQUEUE;
  ActionVendor     if t == VENDOR;
}

def Action : type = record {
  type    : ActionType;
  length  : nat(16,msbf);
  payload : ActionPayload;
  
  restrict(length - 4, payload);
}

def PortID : type = enum(nat(16,msbf)) {
  0..65280
}

def PacketOut : type = record {
  buffer_id   : nat(32,msbf);
  in_port     : PortID;
  actions_len : nat(16,msbf);
  actions     : vector(Action);
  data        : vector(nat(8));
  
  restrict(actions_len, data);
}

def FlowModCommand : type = enum(nat(16,msbf)) {
  ADD           = 0,
  MODIFY        = 1,
  MODIFY_STRICT = 2,
  DELETE        = 3,
  DELETE_STRICT = 4,
}

def FlowModFlags : type = enum(nat(16,msbf)) {
  SEND_FLOW_REM	= 0,
  CHECK_OVERLAP = 1,
  EMERG         = 2,
}

def FlowMod : type = record {
  match        : Match;
  cookie       : nat(64,msbf); 
  command      : FlowModCommand;
  idle_timeout : nat(16,msbf);
  hard_timeout : nat(16,msbf);
  priority     : nat(16,msbf); 
  buffer_id    : nat(32,msbf);
  out_port     : nat(16,msbf);
  flags        : FlowModFlags;
  actions      : vector(Action);	
}

def PortModConfig : type = enum(nat(32,msbf)) {	
  PORT_DOWN	  = 1,
  NO_STP      = 2,
  NO_RECV     = 4,
  NO_RECV_STP = 8,
  NO_FLOOD    = 16,
  NO_FWD      = 32,
  NO_PACKETIN = 64
}

def PortMod : type = record {
  port      : nat(16,msbf);
  hw_addr   : nat(48,msbf);
  config    : PortModConfig;
  mask      : PortConfig;
  advertise : PortFeature;
            : nat(32);
}

def StatsType : type = enum(nat(16,msbf)) {	
  DESC      = 0,
  FLOW      = 1,
  AGGREGATE = 2,
  TABLE     = 3,
  PORT      = 4,
  QUEUE     = 5,
  VENDOR    = 6
}

def StatsReqDesc : type = record {}

def StatsReqFlow : type = record {
  match    : Match;
  table_id : nat(8);
           : nat(8);
  out_port : PortID;
}

def StatsReqAggregate : type = record {
  match    : Match;
  table_id : nat(8);
           : nat(8);
  out_port : PortID;
}

def StatsReqPort : type = record {
  port_no : PortID;
          : nat(48);
}

def StatsReqTable : type = record {}

def StatsReqQueue : type = record {
  port_no  : PortID;
           : nat(16);
  queue_id : nat(32,msbf);	  
}

def StatsReqVendor : type = record {
  vendor_id : nat(32,msbf);
  data      : vector(nat(8));
}

def StatsReqPayload(t:StatsType):type = variant {
  StatsReqDesc      if t == DESC;
  StatsReqFlow      if t == FLOW;
  StatsReqAggregate if t == AGGREGATE;
  StatsReqPort      if t == PORT;
  StatsReqTable     if t == TABLE;
  StatsReqQueue     if t == QUEUE;
  StatsReqVendor    if t == VENDOR;
}
  
def StatsReq : type = record {
  type    : StatsType;
  flags   : nat(16,msbf);
  payload : StatsReqPayload;
}

def StatsResDesc : type = record {
  mfr_desc   : nat(2048,msbf);
  hw_desc    : nat(2048,msbf);
  sw_desc    : nat(2048,msbf);
  serial_num : nat(256,msbf);
  dp_desc    : nat(2048,msbf);
}

def StatsResFlow : type = record {
  length        : nat(16,msbf);
  table_id      : nat(8);
                : nat(8);
  match         : Match;
  duration_sec  : nat(32,msbf); 	
  duration_nsec : nat(32,msbf);
  priority      : nat(16,msbf);
  idle_timeout  : nat(16,msbf); 
  hard_timeout  : nat(16,msbf);  
                : nat(48);
  cookie        : nat(64,msbf);  
  packet_count  : nat(64,msbf); 
  byte_count    : nat(64,msbf); 
  actions       : vector(Action);
}

def StatsResFlows : type = record {
  flows : vector(StatsResFlow);
}

def StatsResAggregate : type = record {
  packet_count : nat(64,msbf); 
  byte_count   : nat(64,msbf); 
  flow_count   : nat(32,msbf); 
               : nat(32);
}

def StatsResPort : type = record {
  port_no      : PortID;
               : nat(48);
  rx_packets   : nat(64,msbf); 
  tx_packets   : nat(64,msbf);   
  rx_bytes     : nat(64,msbf); 
  tx_bytes     : nat(64,msbf); 
  rx_dropped   : nat(64,msbf); 
  tx_dropped   : nat(64,msbf);
  rx_errors    : nat(64,msbf); 
  tx_errors    : nat(64,msbf);   
  rx_frame_err : nat(64,msbf);  
  rx_over_err  : nat(64,msbf);  
  rx_crc_err   : nat(64,msbf);  
  collisions   : nat(64,msbf);  
}

def StatsResPorts : type = record {
  ports : vector(StatsResPort);
}

def StatsReqTable : type = record {
  table_id      : nat(8);
                : nat(24);
  name          : nat(128,msbf); 
  wildcards     : nat(32,msbf);
  max_entries   : nat(32,msbf);
  active_count  : nat(32,msbf);
  lookup_count  : nat(64,msbf);
  matched_count : nat(64,msbf);  
}

def StatsReqTables : type = record {
  tables : vector(StatsResTable);
}

def StatsResQueue : type = record {
  length     : nat(16,msbf);
             : nat(16);
  queue_id   : nat(32,msbf);	
  tx_bytes   : nat(64,msbf); 
  tx_packets : nat(64,msbf); 
  tx_errors  : nat(64,msbf);   
}

def StatsResQueues : type = record {
  queues : vector(StatsResQueue);
}

def StatsResVendor : type = record {
  vendor_id : nat(32,msbf);
  data      : vector(nat(8));
}

def StatsResPayload(t:StatsType):type = variant {
  StatsResDesc      if t == DESC;
  StatsResFlows     if t == FLOW;
  StatsResAggregate if t == AGGREGATE;
  StatsResPorts     if t == PORT;
  StatsResTables    if t == TABLE;
  StatsResQueues    if t == QUEUE;
  StatsResVendor    if t == VENDOR;
}

def StatsRes : type = record {
  type    : StatsType;
  flags   : nat(16,msbf);
  payload : StatsResPayload;
}

def BarrierReq : type = record {}
def BarrierRes : type = record {}

def QueueGetConfigReq : type = record {
  port : PortID;
       : nat(16);
}

def Property : type = enum(nat(16,msbf)) {	
  MIN_RATE = 1
}

def QueuePropertyMinRate : type = record {
  rate : nat(16,msbf);
       : nat(48,msbf);
}

def QueueProperyPayload(t:Property):type = variant {
  QueuePropertyMinRate if t == MIN_RATE;
}

def QueueProperty : type = record {
  property : Property;
  length   : nat(16,msbf);
           : nat(32,msbf);
  payload  : QueueProperyPayload;
  
  restrict(length - 8, payload);
}

def Queue : type = record {
  queue_id   : nat(32,msbf);
  length     : nat(16,msbf);
             : nat(16,msbf);
  properties : vector(QueueProperty);

  restrict(length - 8, properties);  
}

def QueueGetConfigRes : type = record {
  port   : PortID;
         : nat(48);
  queues : vector(Queue);	   
}

def Payload(t:Type):type = variant {
  Hello             if t == HELLO;
  Error             if t == ERROR;
  EchoReq           if t == ECHO_REQ;
  EchoRes           if t == ECHO_RES;
  Vendor            if t == VENDOR;
  FeatureReq        if t == FEATURE_REQ;
  FeatureRes        if t == FEATURE_RES;
  GetConfigReq      if t == GET_CONFIG_REQ;
  GetConfigRes      if t == GET_CONFIG_RES;
  SetConfig         if t == SET_CONFIG;
  PacketIn          if t == PACKET_IN;
  FlowRemoved       if t == FLOW_REMOVED;
  PortStatus        if t == PORT_STATUS;
  PacketOut         if t == PACKET_OUT;
  FlowMod           if t == FLOW_MOD;
  PortMod           if t == PORT_MOD;
  StatsReq          if t == STATS_REQ;
  StatsRes          if t == STATS_RES;
  BarrierReq        if t == BARRIER_REQ;
  BarrierRes        if t == BARRIER_RES;
  QueueGetConfigReq if t == QUEUE_GET_CONFIG_REQ;
  QueueGetConfigRes if t == QUEUE_GET_CONFIG_RES;
}

def Message : type = record {
  version : Version;
  type    : Type;
  length  : nat(16,msbf);
  xid     : nat(32,msbf);
  payload : Payload;

  restrict(length - 8, payload); 
}

} // v1_0 namspace
} // ofp namespace 