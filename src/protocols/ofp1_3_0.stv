def ofp : namespace {

def Version : type = enum(nat(8)) {
  OFP_1_3 = 4
}

def v1_3 : namespace {

def Type : type = enum(nat(8)) {
  HELLO = 0, ERROR = 1, 
  ECHO_REQ = 2, ECHO_RES = 3, 
  EXPERIMENTER = 4,
  FEATURE_REQ = 5, FEATURE_RES = 6, 
  GET_CONFIG_REQ = 7, GET_CONFIG_RES = 8, SET_CONFIG = 9, 
  PACKET_IN = 10, 
  FLOW_REMOVED = 11, 
  PORT_STATUS = 12,
  PACKET_OUT = 13, 
  FLOW_MOD = 14, GROUP_MOD = 15, PORT_MOD = 16, TABLE_MOD = 17
  MULTIPART_REQ = 18, MULTIPART_RES = 19, 
  BARRIER_REQ = 20, BARRIER_RES = 21,
  QUEUE_GET_CONFIG_REQ = 22, QUEUE_GET_CONFIG_RES = 23, 
  ROLE_REQ = 24, ROLE_RES = 25, 
  GET_ASYNC_REQ = 26, GET_ASYNC_RES = 27, SET_ASYNC = 28,
  METER_MOD = 29
}

def HelloType : type = enum(nat(16,msbf)) {
  VERSION_BITMAP = 1
}

def HelloPayload(ht:HelloType) : type = variant {
  nat(32,msbf) if ht == VERSION_BITMAP;
}

def HelloElement : type = record {
  type : HelloType;
  length : nat(16,msbf);
  payload : HelloPayload(type);
}

def Hello : type = record {
  elements : vector(HelloElement);
}

ErrorType : type = enum(nat(16,msbf)) {
  HELLO_FAILED          = 0,
  BAD_REQUEST           = 1,
  BAD_ACTION            = 2,
  BAD_INSTRUCTION       = 3,
  BAD_MATCH             = 4,
  FLOW_MOD_FAILED       = 5,
  GROUP_MOD_FAILED      = 6,
  PORT_MOD_FAILED       = 7,
  TABLE_MOD_FAILED      = 8,
  QUEUE_OP_FAILED       = 9,
  SWITCH_CONFIG_FAILED  = 10,
  ROLE_REQUEST_FAILED   = 11,
  METER_MOD_FAILED      = 12,
  TABLE_FEATURES_FAILED = 13
}

HelloFailedCode : type = enum(nat(16,msbf)) {
  INCOMPATIBLE = 0,
  EPERM        = 1  
}

BadRequestCode : type = enum(nat(16,msbf)) {
  BAD_VERSION               = 0,
  BAD_TYPE                  = 1,
  BAD_MULTIPART             = 2,
  BAD_EXPERIMENTER          = 3,
  BAD_EXPERIMENTER_TYPE     = 4,
  EPERM                     = 5,
  BAD_LENGTH                = 6,
  BUFFER_EMPTY              = 7,
  BUFFER_UNKNOWN            = 8,
  BAD_TABLE_ID              = 9,
  IS_SLAVE                  = 10,
  BAD_PORT                  = 11,
  BAD_PACKET                = 12,
  MULTIPART_BUFFER_OVERFLOW = 13
}

BadActionCode : type = enum(nat(16,msbf)) {
  BAD_TYPE              = 0,
  BAD_LENGTH            = 1,
  BAD_EXPERIMENTER      = 2,
  BAD_EXPERIMENTER_TYPE = 3,
  BAD_OUT_PORT          = 4,
  BAD_ARGUMENT          = 5,
  EPERM                 = 6,
  TOO_MANY              = 7,
  BAD_QUEUE             = 8,
  BAD_OUT_GROUP         = 9,
  MATCH_INCONSISTENT    = 10,
  UNSUPPORTED_ORDER     = 11,
  BAD_TAG               = 12,
  BAD_SET_TYPE          = 13,
  BAD_SET_LENGTH        = 14,
  BAD_SET_ARGUMENT      = 15
}

BadInstructionCode : type = enum(nat(16,msbf)) {
  UNKNOWN_INST          = 0,
  UNSUP_INST            = 1,
  BAD_TABLE_ID          = 2,
  UNSUP_METADATA        = 3,
  UNSUP_METADATA_MASK   = 4,
  BAD_EXPERIMENTER      = 5
  BAD_EXPERIMENTER_TYPE = 6,
  BAD_LENGTH            = 7,
  EPERM                 = 8
}

BadMatch : type = enum(nat(16,msbf)) {
  BAD_TYPE         = 0,
  BAD_LENGTH       = 1,
  BAD_TAG          = 2,
  BAD_DL_ADDR_MASK = 3,
  BAD_HW_ADDR_MASK = 4,
  BAD_WILDCARDS    = 5,
  BAD_FIELD        = 6,
  BAD_VALUE        = 7,
  BAD_MASK         = 8,
  BAD_PREREQ       = 9,
  DUPLICATE_FIELD  = 10,
  EPERM            = 11
}

FlowModFailedCode : type = enum(nat(16,msbf)) {
  UNKNOWN      = 0,
  TABLE_FULL   = 1,
  BAD_TABLE_ID = 2,
  OVERLAP      = 3,
  EPERM        = 4,
  BAD_TIMEOUT  = 5,
  BAD_COMMAND  = 6,
  BAD_FLAGS    = 7
}

GroupModFailedCode : type = enum(nat(16,msbf)) {
  GROUP_EXISTS         = 0,
  INVALID_GROUP        = 1,
  WEIGHT_UNSUPPORTED   = 2,
  OUT_OF_GROUPS        = 3,
  OUT_OF_BUCKETS       = 4,
  CHAINING_UNSUPPORTED = 5,
  WATCH_UNSUPPORTED    = 6,
  LOOP                 = 7,
  UNKNOWN_GROUP        = 8,
  CHAINED_GROUP        = 9,
  BAD_TYPE             = 10,
  BAD_COMMAND          = 11,
  BAD_BUCKET           = 12,
  BAD_WATCH            = 13,
  EPERM                = 14
}

PortModFailedCode : type = enum(nat(16,msbf)) {
  BAD_PORT      = 0,
  BAD_HW_ADDR   = 1,
  BAD_CONFIG    = 2,
  BAD_ADVERTISE = 3,
  EPERM         = 4
}

TableModFailedCode : type = enum(nat(16,msbf)) {
  BAD_TABLE  = 0,
  BAD_CONFIG = 1,
  EPERM      = 2
}

QueueOpFailedCode : type = enum(nat(16,msbf)) {
  BAD_PORT  = 0,
  BAD_QUEUE = 1,
  EPERM     = 2
}

SwitchConfigFailedCode : type = enum(nat(16,msbf)) {
  BAD_FLAGS = 0,
  BAD_LEN   = 1,
  EPERM     = 2
}

RoleRequestFailedCode : type = enum(nat(16,msbf)) {
  STALE       = 0,
  UNSUPPORTED = 1,
  BAD_ROLE    = 2
}

MeterModFailedCode : type = enum(nat(16,msbf)) {
  UNKNOWN        = 0,
  METER_EXISTS   = 1,
  INVALID_METER  = 2,
  UNKNOWN_METER  = 3,
  BAD_COMMAND    = 4,
  BAD_FLAGS      = 5,
  BAD_RATE       = 6,
  BAD_BURST      = 7,
  BAD_BAND       = 8,
  BAD_BAND_VALUE = 9,
  OUT_OF_METERS  = 10,
  OUT_OF_BANDS   = 11
}

TableFeaturesFailedCode : type = enum(nat(16,msbf)) {
  BAD_TABLE    = 0,
  BAD_METADATA = 1,
  BAD_TYPE     = 2,
  BAD_LENGTH   = 3,
  BAD_ARGUMENT = 4,
  EPERM        = 5
} 

def ErrorCode(t:ErrorType):type = variant {
  HelloFailedCode         if t == HELLO_FAILED;
  BadRequestCode          if t == BAD_REQUEST;
  BadActionCode           if t == BAD_ACTION;
  BadInstructionCode      if t == BAD_INSTRUCTION;
  BadMatch                if t == BAD_MATCH;     
  FlowModFailedCode       if t == FLOW_MOD_FAILED;
  GroupModFailedCode      if t == GROUP_MOD_FAILED;
  PortModFailedCode       if t == PORT_MOD_FAILED;
  TableModFailedCode      if t == TABLE_MOD_FAILED;
  QueueOpFailedCode       if t == QUEUE_OP_FAILED;
  SwitchConfigFailedCode  if t == SWITCH_CONFIG_FAILED;
  RoleRequestFailedCode   if t == ROLE_REQUEST_FAILED;
  MeterModFailedCode      if t == METER_MOD_FAILED;
  TableFeaturesFailedCode if t == TABLE_FEATURES_FAILED;
}

def Error : type = record {
  type : ErrorType;
  code : ErrorCode;
  data : vector(nat(8));
}

def EchoReq : type = record {
  data : vector(nat(8));
}

def EchoRes : type = record {
  data : vector(nat(8));
}

def Experimenter : type = record {
  id   : nat(32,msbf);
  data : vector(nat(8));
}

def FeatureCapabilities : type = enum(nat(32,msbf)) {
  0..511,
  FLOW_STATS   = 1,
  TABLE_STATS  = 2,
  PORT_STATS   = 4,
  GROUP_STATS  = 8,
  IP_REASM     = 32,
  QUEUE_STATS  = 64,
  PORT_BLOCKED = 256
}

def FeatureRes : type = record {
  datapath-id  : nat(64,msbf);
  n_buffers    : nat(32,msbf);
  n_tables     : nat(8);
  aux_id       : nat(8);
               : nat(24);
  capabilities : FeatureCapabilities;
  reserved     : nat(32,msbf);
}

def GetConfigReq : type = record {}

def ConfigFlags : type = enum(nat(16,msbf)) {
  FRAG_NORMAL = 0,
  FRAG_DROP   = 1,
  FRAG_REASM  = 2,
  FRAG_MASK   = 3,
}

def GetConfigRes : type = record {
  flags : ConfigFlags;
  miss_send_len : nat(16,msbf);
}

def SetConfig : type = record {
  flags : ConfigFlags;
  miss_send_len : nat(16,msbf);
}

def PacketInReason : type = enum(nat(8)) {
  NO_MACTH    = 0,
  ACTION      = 1,
  INVALID_TTL = 2
}

def MatchType : type = enum(nat(16, msbf)) {
  STANDARD = 0,
  OXM      = 1
}

def OxmClass : type = enum(nat(8)) {
  NXM_0          = 0;
  NXM_1          = 1;
  OPENFLOW_BASIC = 32768;
}

def OxmHeader : type = record {
  class   : OxmClass;
  field   : OxmField;
  hasmask : nat(1);
]

def OxmField : type = enum(nat(7)) {
  IN_PORT        = 0,
  IN_PHY_PORT    = 1,
  METADATA       = 2,
  ETH_DST        = 3,
  ETH_SRC        = 4,
  ETH_TYPE       = 5,
  VLAN_VID       = 6,
  VLAN_PCP       = 7,
  IP_DSCP        = 8,
  IP_ECN         = 9,
  IP_PROTO       = 10,
  IPV4_SRC       = 11,
  IPV4_DST       = 12,
  TCP_SRC        = 13,
  TCP_DST        = 14,
  UDP_SRC        = 15,
  UDP_DST        = 16,
  SCTP_SRC       = 17,
  SCTP_DST       = 18,
  ICMPV4_TYPE    = 19,
  ICMPV4_CODE    = 20,
  ARP_OP         = 21,
  ARP_SPA        = 22,
  ARP_TPA        = 23,
  ARP_SHA        = 24,
  ARP_THA        = 25,
  IPV6_SRC       = 26,
  IPV6_DST       = 27,
  IPV6_FLABEL    = 28,
  ICMPV6_TYPE    = 29,
  ICMPV6_CODE    = 30,
  IPV6_ND_TARGET = 31,
  IPV6_ND_SLL    = 32,
  IPV6_ND_TLL    = 33,
  MPLS_LABEL     = 34,
  MPLS_TC        = 35,
  MPLS_BOS       = 36,
  PBB_ISID       = 37,
  TUNNEL_ID      = 38,
  IPV6_HEXTHDR   = 39,
  EXPERIMENTER   = 127
}

def OxmInPort : type = record {
  in_port : nat(32,msbf);
}

def OxmInPhyPort : type = record {
  in_phy_port : nat(32,msbf);
}

def OxmMetadata : type = record {
  metadata : nat(64,msbf);
}

def OxmEthDst : type = record {
  eth_dst : nat(48,msbf);
}

def OxmEthSrc : type = record {
  eth_src : nat(48,msbf);
}

def OxmEthType : type = record {
  eth_src : nat(16,msbf);
}

def OxmVlanVid : type = record {
  vlan_vid : nat(13,msbf);
}

def OxmVlanPcp : type = record {
  vlan_pcp : nat(3);
}

def OxmIpDscp : type = record {
  ip_dscp : nat(6);
}

def OxmIpEcn : type = record {
  ip_ecn : nat(2);
}

def OxmIpProto : type = record {
  ip_proto : nat(8);
}

def OxmIpv4Src : type = record {
  ipv4_src : nat(32,msbf);
}

def OxmIpv4Dst : type = record {
  ipv4_dst : nat(32,msbf);
}

def OxmTcpSrc : type = record {
  tcp_src : nat(16,msbf);
}

def OxmTcpDst : type = record {
  tcp_dst : nat(16,msbf);
}

def OxmUdpSrc : type = record {
  udp_src : nat(16,msbf);
}

def OxmUdpDst : type = record {
  udp_dst : nat(16,msbf);
}

def OxmSctpSrc : type = record {
  sctp_src : nat(16,msbf);
}

def OxmSctpDst : type = record {
  sctp_dst : nat(16,msbf);
}

def OxmIpv4Type : type = record {
  ipv4_type : nat(8);
}

def OxmIpv4Code : type = record {
  ipv4_code : nat(8);
}

def OxmArpOp : type = record {
  arp_op : nat(16,msbf);
}

def OxmArpSpa : type = record {
  arp_spa : nat(32,msbf);
}

def OxmArpTpa : type = record {
  arp_tpa : nat(32,msbf);
}

def OxmArpSha : type = record {
  arp_sha : nat(48,msbf);
}

def OxmArpTha : type = record {
  arp_tha : nat(48,msbf);
}

def OxmIpv6Src : type = record {
  ipv6_src : nat(128,msbf);
}

def OxmIpv6Dst : type = record {
  ipv6_dst : nat(128,msbf);
}

def OxmIpv6Flabel : type = record {
  ipv6_flabel : nat(20,msbf);
}

def OxmIcmpv6Type : type = record {
  ipcmv6_type : nat(8);
}

def OxmIpv6NdTarget : type = record {
  ipv6_nd_target : nat(128,msbf);
}

def OxmIpv6NdSll : type = record {
  ipv6_nd_sll : nat(48,msbf);
}

def OxmIpv6NdTll : type = record {
  ipv6_nd_tll : nat(48,msbf);
}

def OxmMplsLabel : type = record {
  mpls_label : nat(20,msbf);
}

def OxmMplsTc : type = record {
  mpls_tc : nat(3);
}

def OxmMplsBos : type = record {
  mpls_bos : nat(1);
}

def OxmPbbIsid : type = record {
  pbb_isid : nat(24,msbf);
}

def OxmTunnelId : type = record {
  tunnel_id : nat(64,msbf);
}

def OxmIpv6Hexthdr : type = record {
  ipv6_hexthdr : nat(9,msbf);
}

def OxmPayload(t:OxmField):type = variant {
  OxmInPort       if t == IN_PORT;
  OxmInPhyPort    if t == IN_PHY_PORT;
  OxmMetadata     if t == METADATA;
  OxmEthDst       if t == ETH_DST;
  OxmEthSrc       if t == ETH_SRC;
  OxmEthType      if t == ETH_TYPE;
  OxmVlanVid      if t == VLAN_VID;
  OxmVlanPcp      if t == VLAN_PCP;
  OxmIpDscp       if t == IP_DSCP;  
  OxmIpEcn        if t == IP_ECN;
  OxmIpProto      if t == IP_PROTO;
  OxmIpv4Src      if t == IPV4_SRC;
  OxmIpv4Dst      if t == IPV4_DST;
  OxmTcpSrc       if t == TCP_SRC;
  OxmTcpDst       if t == TCP_DST;
  OxmUdpSrc       if t == UDP_SRC;
  OxmUdpDst       if t == UDP_DST;
  OxmSctpSrc      if t == SCTP_SRC;
  OxmSctpDst      if t == SCTP_DST;
  OxmIcmpv4Type   if t == ICMPV4_TYPE;
  OxmIcmpv4Code   if t == ICMPV4_CODE;
  OxmArpOp        if t == ARP_OP;
  OxmArpSpa       if t == ARP_SPA;
  OxmArpTpa       if t == ARP_TPA;
  OxmArpTha       if t == ARP_THA;
  OxmIpv6Src      if t == IPV6_SRC;
  OxmIpv6Dst      if t == IPV6_DST;
  OxmIpv6Flabel   if t == IPV6_FLABEL;
  OxmIcmpv6Type   if t == ICMPV6_TYPE;
  OxmIcmpv6Code   if t == ICMPV6_CODE; 
  OxmIpv6NdTarget if t == IPV6_ND_TARGET;
  OxmIpv6NdSll    if t == IPV6_ND_SLL;
  OxmIpv6NdTll    if t == IPV6_ND_TLL;
  OxmMplsLabel    if t == MPLS_LABEL;
  OxmMplsTc       if t == MPLS_TC;
  OxmMplsBos      if t == MPLS_BOS;
  OxmPbbIsid      if t == PBB_ISID;
  OxmTunnelId     if t == TUNNEL_ID;
  OxmIpv6Hexthdr  if t == IPV6_HEXTHDR;
}

def Oxm : type = record {
  header  : OxmHeader;
  payload : OxmPayload;

  restrict(length - 4, payload);
}

def Match : type = record {
  type        : MatchType;
  length      : nat(16,msbf);
              : nat(32);
  oxms        : vector(Oxm));			  
}  

def PacketIn : type = record {
  buffer_id   : nat(32,msbf);
  total_len   : nat(16,msbf);
  reason      : PacketInReason;
  table_id    : nat(8);
  cookie      : nat(32,msbf);
  match       : Match;
              : nat(16);
  data        : vector(nat(8));
}

def FlowRemovedReason : type = enum(nat(8)) {
  IDLE_TIMEOUT = 0,
  HARD_TIMEOUT = 1,
  DELETE       = 2,
  GROUP_DELETE = 3
}

def FlowRemoved : type = record {
  cookie        : nat(64,msbf);
  priority      : nat(16,msbf);  
  reason    	: FlowRemovedReason;
  table_id      : nat(8);
  duration_sec  : nat(32,msbf); 
  duration_nsec : nat(32,msbf);   
  idle_timeout  : nat(16,msbf);
  hard_timeout  : nat(16,msbf);
  packet_count  : nat(64,msbf); 
  byte_count    : nat(64,msbf);
  match         : Match;  
}

def PortStatusReason : type = enum(nat(8)) {
  ADD 	 = 0,
  DELETE = 1,
  MODIFY = 2
}

def Port_Id : type = enum(nat(32,msbf)) {
  0..4294967039
  MAX        = 4294967040,
  IN_PORT    = 4294967288,
  TABLE      = 4294967289,
  NORMAL     = 4294967290,
  FLOOD      = 4294967291,
  ALL        = 4294967292,
  CONTROLLER = 4294967293,
  LOCAL      = 4294967294,
  ANY        = 4294967295
}

def PortConfig : type = enum(nat(32,msbf)) {
  0..127,
  PORT_DOWN	  = 1,
  NO_RECV     = 4,
  NO_FWD      = 32,
  NO_PACKETIN = 64
}

def PortState : type = enum(nat(32,msbf)) {
  0..7,
  LINK_DOWN   = 1,
  BLOCKED     = 2,
  LIVE        = 4
}

def PortFeature : type = enum(nat(32,msbf)) {
  0..65535,
  10MB_HD    = 1,
  10MB_FD    = 2,
  100MD_HD   = 4,
  100MD_FD   = 8,
  1GB_HD     = 16,
  1GB_FD     = 32,
  10GB_FD    = 64,
  40GB_FD    = 128,
  100GB_FD   = 256,
  1TB_FD     = 512, 
  OTHER      = 1024,
  COPPER     = 2048,
  FIBER      = 4096,
  AUTO_NEG   = 8192,
  PAUSE      = 16384,
  PAUSE_ASYM = 32768
}

def Port : type = record {
  port_id    : Port_Id;
             : nat(32);
  hw_addr    : nat(48,msbf);
  name       : nat(128,msbf);
  config     : PortConfig;
  state      : PortState;
  curr       : PortFeature;
  advertised : PortFeature;
  supported  : PortFeature;
  peer       : PortFeature;
  curr_speed : nat(32,msbf);
  max_speed  : nat(32,msbf);
}

def PortStatus : type = record {
  reason : PortStatusReason;
         : nat(56);  
  port   : Port		 
}

def PortID : type = enum(nat(32,msbf)) {
  0..4294967040
}

def ActionType : type = enum(nat(16,msbf)) {
  OUTPUT         = 0,
  COPY_TTL_OUT   = 11,
  COPY_TTL_IN    = 12,
  SET_MPLS_TLL   = 15,
  DEC_MPLS_TLL   = 16,
  PUSH_VLAN      = 17,
  POP_VLAN       = 18,
  PUSH_MPLS      = 19,
  POP_MPLS       = 20,
  SET_QUEUE      = 21,
  GROUP          = 22,
  SET_NW_TTL     = 23,
  DEC_NW_TTL     = 24,
  SET_FIELD      = 25,
  PUSH_PBB       = 26,
  POP_PBB        = 27,
  EXPERIMENTER   = 65535
}

def ActionHeader : type = record {
  type    : ActionType;
  length  : nat(16,msbf);
}

def ActionOutput : type = record {
  port    : Port_id;
  max_len : nat(16,msbf);
          : nat(48);
}

def ActionCopyTtlOut : type = record {}
def ActionCopyTtlIn : type = record {}

def ActionSetMplsTtl : type = record {
  mpls_ttl : nat(8);
           : nat(24);
}

def ActionDecMplsTtl : type = record {}

def ActionPushVlan : type = record {
  ethertype : nat(16,msbf);
            : nat(16);
}

def ActionPopVlan : type = record {}

def ActionPushMpls : type = record {
  mpls : nat(16,msbf);
       : nat(16);
}

def ActionPopMpls : type = record {}

def ActionSetQueue : type = record {
  queue_id : nat(32,msbf);
}

def ActionGroup : type = record {
  group_id : nat(32,msbf);
}

def ActionSetNwTtl : type = record {
  ttl : nat(8);
      : nat(24);
}

def ActionDecNwTtl : type = record {}

def ActionSetField : type = record {
  oxm : Oxm;
}

def ActionPushPbb : type = record {
  ethertype : nat(16,msbf);
            : nat(16);
}

def ActionPopPbb : type = record {}

def ActionExperimenter : type = record {
  experimenter : nat(32,msbf);
}

def ActionPayload(t:ActionType):type = variant {
  ActionOutput       if t == OUTPUT;
  ActionCopyTtlOut   if t == COPY_TTL_OUT;
  ActionCopyTtlIn    if t == COPY_TTL_IN;
  ActionSetMplsTtl   if t == SET_MPLS_TTL;
  ActionDecMplsTtl   if t == DEC_MPLS_TTL;
  ActionPushVlan     if t == PUSH_VLAN;
  ActionPopVlan      if t == POP_VLAN;
  ActionPushMpls     if t == PUSH_MPLS;
  ActionPopMpls      if t == POP_MPLS;
  ActionSetQueue     if t == SET_QUEUE;
  ActionGroup        if t == GROUP;
  ActionSetNwTtl     if t == SET_NW_TTL;
  ActionDecNwTtl     if t == DEC_NW_TTL;
  ActionSetField     if t == SET_FIELD;
  ActionPushPbb      if t == PUSH_PBB;
  ActionPopPbb       if t == POP_PBB;
  ActionExperimenter if t == EXPERIMENTER;
}

def Action : type = record {
  header  : ActionHeader;
  payload : ActionPayload;
  
  restrict(length - 4, payload);
}

def PacketOut : type = record {
  buffer_id   : nat(32,msbf);
  in_port     : PortID;
  actions_len : nat(16,msbf);
              : nat(32);
  actions     : vector(Action);
  data        : vector(nat(8));
  
  restrict(actions_len, data);
}

def FlowModCommand : type = enum(nat(8)) {
  ADD           = 0,
  MODIFY        = 1,
  MODIFY_STRICT = 2,
  DELETE        = 3,
  DELETE_STRICT = 4,
}

def FlowModFlags : type = enum(nat(16,msbf)) {
  SEND_FLOW_REM	   = 1,
  CHECK_OVERLAP    = 2,
  RESET_COUNTS     = 4,
  NO_PACKET_COUNTS = 16,
  NO_BYTE_COUNTS   = 32
}

def InstructionType : type = enum(nat(16,msbf)) {
  GOTO_TABLE     = 1,
  WRITE_METADATA = 2,
  WRITE_ACTIONS  = 3,
  APPLY_ACTIONS  = 4,
  CLEAR_ACTIONS  = 5,
  METER          = 6,
  EXPERIMENTER   = 65535
}

def InstructionGotoTable : type = record {
  table_id : nat(8);
           : nat(24);
}

def InstructionWriteMetadata : type = record {
                : nat(32);
  metadata      : nat(64,msbf);
  metadata_mask : nat(64,msbf);
}

def InstructionWriteActions : type = record {
          : nat(32);
  actions : vector(Action);
}

def InstructionApplyActions : type = record {
          : nat(32);
  actions : vector(Action);
}

def InstructionClearActions : type = record {
          : nat(32);
  actions : vector(Action);
}

def InstructionMeter : type = record {
  meter_id : nat(32,msbf);
}

def InstructionExperimenter : type = record {
  experimenter_id : nat(32,msbf);
}

def InstructionPayload(t:ActionType):type = variant {
  InstructionGotoTable     if t == GOTO_TABLE;
  InstructionWriteMetadata if t == WRITE_METADATA;
  InstructionWriteActions  if t == WRITE_ACTIONS;
  InstructionApplyActions  if t == APPLY_ACTIONS;
  InstructionClearActions  if t == CLEAR_ACTIONS;
  InstructionMeter         if t == METER;
  Experimenter             if t == EXPERIMENTER;
}
  
def Instruction : type = record {
  type    : InstructionType;
  length  : nat(16,msbf);
  payload : InstructionPayload;
  
  restrict(length - 4, payload);
}

def FlowMod : type = record {
  cookie       : nat(64,msbf);
  cookie_mask  : nat(64,msbf);
  table_id     : nat(8);  
  command      : FlowModCommand;
  idle_timeout : nat(16,msbf);
  hard_timeout : nat(16,msbf);
  priority     : nat(16,msbf); 
  buffer_id    : nat(32,msbf);
  out_port     : nat(32,msbf);
  out_group    : nat(32,msbf);
  flags        : FlowModFlags;
               : nat(16);
  match        : Match;
  instructions : vector(Instruction);	
}

def GroupModCommand : type = enum(nat(16,msbf)) {
  ADD    = 0,
  MODIFY = 1,
  DELETE = 2
}

def GroupModType : type = enum(nat(8)) {
  ALL           = 0,
  SELECT        = 1,
  INDIRECT      = 2,
  FAST_FAILOVER = 3
}

def Bucket : type = record {
  length        : nat(16,msbf);
  weight        : nat(16,msbf);
  watch_port    : nat(32,msbf);
  watch_group   : nat(32,msbf);
                : nat(32);
  action_header : ActionHeader;
}

def GroupMod : type = record {
  command  : GroupModCommand;
  type     : GroupModType;
           : nat(8);
  group_id : nat(32,msbf);
  buckets  : vector(Bucket);
}

def PortModConfig : type = enum(nat(32,msbf)) {	
  PORT_DOWN	  = 1,
  NO_STP      = 2,
  NO_RECV     = 4,
  NO_RECV_STP = 8,
  NO_FLOOD    = 16,
  NO_FWD      = 32,
  NO_PACKETIN = 64
}

def PortMod : type = record {
  port      : Port_Id;
            : nat(32);
  hw_addr   : nat(48,msbf);
            : nat(16);
  config    : PortModConfig;
  mask      : PortConfig;
  advertise : PortFeature;
            : nat(32);
}

def Table_Id : type = enum(nat(8)) {	
  0..254
}

def TableModConfig: type = enum(nat(32,msbf)) {	
  MISS_CONTROLLER = 0,
  MISS_CONTINUE   = 1,
  MISS_DROP       = 2,
  MISS_MASK       = 3
}

def TableMod : type = record {
  table_id : Table_Id;
           : nat(24);  
  config   : TableModConfig; 
}

def MultipartType : type = enum(nat(16,msbf)) {	
  DESC           = 0,
  FLOW           = 1,
  AGGREGATE      = 2,
  TABLE          = 3,
  PORT           = 4,
  QUEUE          = 5,
  GROUP          = 6,
  GROUP_DESC     = 7,
  GROUP_FEATURES = 8,
  METER          = 9,
  METER_CONFIG   = 10,
  METER_FEATURES = 11,
  TABLE_FEATURES = 12,
  EXPERIMENTER   = 65535
}

def MultipartReqDesc : type = record {}

def MultipartReqFlow : type = record {
  table_id    : nat(8);
              : nat(24);
  out_port    : Port_Id;
  out_group   : nat(32,msbf);
              : nat(32);
  cookie      : nat(64,msbf);
  cookie_mask : nat(64,msbf);
  match       : Match;
}

def MultipartReqAggregate : type = record {
  table_id    : nat(8);
              : nat(24);
  out_port    : Port_Id;
  out_group   : nat(32,msbf);
              : nat(32);
  cookie      : nat(64,msbf);
  cookie_mask : nat(64,msbf);
  match       : Match;
}

def MultipartReqTable : type = record {}

def MultipartReqPort : type = record {
  port_no : Port_Id;
          : nat(32);
}

def MultipartReqQueue : type = record {
  port_no  : Port_Id;
  queue_id : nat(32,msbf);	  
}

def MultipartReqGroup : type = record {
  group_id : nat(32,msbf);
           : nat(32);  
}

def MultipartReqGroupDesc : type = record {}
def MultipartReqGroupFeatures : type = record {}

def MultipartReqMeter : type = record {
  mater_id : nat(32,msbf);
           : nat(32);  
}

def MultipartReqMeterConfig : type = record {
  mater_id : nat(32,msbf);
           : nat(32);  
}

def MultipartReqMeterFeatures : type = record {}

def MultipartReqTableFeatures : type = record {}

def MultipartReqExperimenter : type = record {
  experimenter_id : nat(32,msbf);
  exp_type        : nat(32,msbf);
  data            : vector(nat(8));
}

def MultipartReqPayload(t:MultipartType):type = variant {
  MultipartReqDesc          if t == DESC;
  MultipartReqFlow          if t == FLOW;
  MultipartReqAggregate     if t == AGGREGATE;
  MultipartReqPort          if t == PORT;
  MultipartReqTable         if t == TABLE;
  MultipartReqQueue         if t == QUEUE;
  MultipartReqGroup         if t == GROUP;
  MultipartReqGroupDesc     if t == GROUP_DESC;
  MultipartReqGroupFeatures if t == GROUP_FEATURES;
  MultipartReqMeter         if t == METER;
  MultipartReqMeterConfig   if t == METER_CONFIG;
  MultipartReqMeterFeatures if t == METER_FEATURES;
  MultipartReqTableFeatures if t == TABLE_FEATURES;
  MultipartReqExperimenter  if t == EXPERIMENTER;
}
  
def MultipartReq : type = record {
  type    : MultipartType;
  flags   : nat(16,msbf);
  payload : MultipartReqPayload;
}

def MultipartResDesc : type = record {
  mfr_desc   : nat(2048,msbf);
  hw_desc    : nat(2048,msbf);
  sw_desc    : nat(2048,msbf);
  serial_num : nat(256,msbf);
  dp_desc    : nat(2048,msbf);
}

def MultipartResFlow : type = record {
  length        : nat(16,msbf);
  table_id      : nat(8);
                : nat(8);
  duration_sec  : nat(32,msbf); 	
  duration_nsec : nat(32,msbf);
  priority      : nat(16,msbf);
  idle_timeout  : nat(16,msbf); 
  hard_timeout  : nat(16,msbf);
  flags         : nat(16,msbf);  
                : nat(32);
  cookie        : nat(64,msbf);  
  packet_count  : nat(64,msbf); 
  byte_count    : nat(64,msbf); 
  match         : Match;
  instructions  : vector(Instruction);
}

def MultipartResFlows : type = record {
  flows : vector(MultipartResFlow);
}

def MultipartResAggregate : type = record {
  packet_count : nat(64,msbf); 
  byte_count   : nat(64,msbf); 
  flow_count   : nat(32,msbf); 
               : nat(32);
}

def MultipartResTable : type = record {
  table_id           : nat(8);
                     : nat(24);
  active_count       : nat(32,msbf);
  lookup_count       : nat(64,msbf);
  matched_count      : nat(64,msbf);  
}

def MultipartResTables : type = record {
  tables : vector(MultipartResTable);
}

def MultipartResPort : type = record {
  port_no       : Port_Id;
                : nat(32);
  rx_packets    : nat(64,msbf); 
  tx_packets    : nat(64,msbf);   
  rx_bytes      : nat(64,msbf); 
  tx_bytes      : nat(64,msbf); 
  rx_dropped    : nat(64,msbf); 
  tx_dropped    : nat(64,msbf);
  rx_errors     : nat(64,msbf); 
  tx_errors     : nat(64,msbf);   
  rx_frame_err  : nat(64,msbf);  
  rx_over_err   : nat(64,msbf);  
  rx_crc_err    : nat(64,msbf);  
  collisions    : nat(64,msbf); 
  duration_sec  : nat(32,msbf);
  duration_nsec : nat(32,msbf);  
}

def MultipartResPorts : type = record {
  ports : vector(MultipartResPort);
}

def MultipartResQueue : type = record {
  length     : nat(32,msbf);
  queue_id   : nat(32,msbf);	
  tx_bytes   : nat(64,msbf); 
  tx_packets : nat(64,msbf); 
  tx_errors  : nat(64,msbf);   
  duration_sec  : nat(32,msbf);
  duration_nsec : nat(32,msbf);   
}

def MultipartResQueues : type = record {
  queues : vector(MultipartResQueue);
}

def BucketCounter : type = record {
  packet_count    : nat(64,msbf); 
  byte_count      : nat(64,msbf);
}

def MultipartResGroup : type = record {
  length          : nat(16,msbf);
                  : nat(16);
  group_id        : nat(32,msbf);
  ref_count       : nat(32,msbf);
                  : nat(32);
  packet_count    : nat(64,msbf); 
  byte_count      : nat(64,msbf);
  duration_sec    : nat(32,msbf);
  duration_nsec   : nat(32,msbf); 
  bucket_counters : vector(BucketCounter)  
}

def MultipartResGroupDesc : type = record {
  length   : nat(16,msbf);
  type     : nat(8);
           : nat(8);
  group_id : nat(32,msbf);
  buckets  : vector(Bucket);
}

def GroupFeatureCapabilities : type = enum(nat(32,msbf)) {
  0..15,
  SELECT_WEIGHT   = 1,
  SELECT_LIVENESS = 2,
  CHAINING        = 4,
  CHAINING_CHECKS = 8
}

def MultipartResGroupFeatures : type = record {
  types : nat(32,msbf);
  capabilities : GroupFeatureCapablities;
  max_groups_all      : nat(32,msbf);
  max_groups_select   : nat(32,msbf);
  max_groups_indirect : nat(32,msbf);
  max_groups_ff       : nat(32,msbf);
  actions_all         : nat(32,msbf);
  actions_select      : nat(32,msbf);
  actions_indirect    : nat(32,msbf);
  actions_ff          : nat(32,msbf);
}

def MeterBandStats : type = record {
  packet_band_count : nat(64,msbf);
  byte_band_count   : nat(64,msbf);
}

def MultipartResMeter : type = record {
  meter_id        : nat(32,msbf);
  len             : nat(16,msbf); 
                  : nat(48);
  flow_count      : nat(32,msbf);
  packet_in_count : nat(64,msbf);
  byte_in_count   : nat(64,msbf);
  duration_sec    : nat(32,msbf);
  duration_nsec   : nat(32,msbf);
  meter_bands     : vector(MeterBandStats);
}

def MultipartResMeters : type = record {
  meters : vector(MultipartMeter);
}

def MultipartResMeterConfig : type = record {
  length   : nat(16,msbf);  
  flags    : nat(16,msbf); 
  meter_id : nat(32,msbf);  
}

def MultipartResMeterConfigs : type = record {
  meter_configs : vector(MultipartMeterConfig);
}

def MeterBandType : type = enum(nat(32,msbf)) {	
  DROP         = 1,
  DSCP_REMARK  = 2,
  EXPERIMENTER = 65535
}

def MeterFlags : type = enum(nat(32,msbf)) {	
  0..15
  KBPS  = 1,
  PKTPS = 2,
  BURST = 4,
  STATS = 8
}

def MultipartResMeterFeatures : type = record {
  max_meter    : nat(32,msbf);
  band_types   : MeterBandType;
  capabilities : MeterFlags;
  max_bands    : nat(8);
  max_color    : nat(8);
               : nat(16);
}

def TableFeaturePropertyType : type = enum(nat(16,msbf)) {	
  INSTRUCTIONS        = 0,
  INSTRUCTIONS_MISS   = 1,
  NEXT_TABLES         = 2,
  NEXT_TABLES_MISS    = 3,
  WRITE_ACTIONS       = 4,
  WRITE_ACTIONS_MISS  = 5,
  APPLY_ACTIONS       = 6,
  APPLY_ACTIONS_MISS  = 7,
  MATCH               = 8,
  WILDCARDS           = 10,
  WRITE_SETFIELD      = 12,
  WRITE_SETFIELD_MISS = 13,
  APPLY_SETFIELD      = 14,
  APPLY_SETFIELD_MISS = 15,
  EXPERIMENTER        = 65534,
  EXPERIMENTER_MISS   = 65535
}

def TableFeaturePropertyInstructions : type = record {
  instruction_ids : vector(Instruction);
}

def TableFeaturePropertyNextTables : type = record {
  next_table_ids : vector(nat(8));
}

def TableFeaturePropertyActions : type = record {
  action_ids : vector(Action);
}

def TableFeaturePropertyOxm : type = record {
  oxm_ids : vector(OxmHeader);
}

def TableFeaturePropertyPayload(t:TableFeaturePropertyType):type = variant {
  TableFeaturePropertyInstructions  if t == INSTRUCTIONS | INSTRUCTIONS_MISS;
  TableFeaturePropertyNextTables    if t == NEXT_TABLES | NEXT_TABLES_MISS;
  TableFeaturePropertyActions       if t == WRITE_ACTIONS | WRITE_ACTIONS_MISS |
                                            APPLY_ACTIONS | APPLY_ACTIONS_MISS;
  TableFeaturePropertyOxm           if t == MATCH | WILDCARDS |
                                            WRITE_SETFIELD | WRITE_SETFIELD_MISS |
                                            APPLY_SETFIELD | APPLY_SETFIELD_MISS;
}

def TableFeatureProperty : type = record {
  type    : TableFeaturePropertyType;
  length  : nat(16,msbf);
  payload : TableFeaturePropertyPayload;
}

def MultipartResTableFeature : type = record {
  length         : nat(16,msbf);
  table_id       : nat(8);
                 : nat(40);
  name           : nat(256);
  metadata_match : nat(64,msbf); 
  metadata_write : nat(64,msbf);
  config         : nat(32,msbf);
  max_entries    : nat(32,msbf);  
  properties     : vector(TableFeatureProperty);
}

def MultipartResTableFeatures : type = record {
  table_features : vector(MultipartResTableFeature);
}

def MultipartResExperimenter : type = record {
  experimenter_id : nat(32,msbf);
  data            : vector(nat(8));
}

def MultipartResPayload(t:MultipartType):type = variant {
  MultipartResDesc          if t == DESC;
  MultipartResFlows         if t == FLOW;
  MultipartResAggregate     if t == AGGREGATE;
  MultipartResPorts         if t == PORT;
  MultipartResTables        if t == TABLE;
  MultipartResQueues        if t == QUEUE;
  MultipartResGroup         if t == GROUP;
  MultipartResGroupDesc     if t == GROUP_DESC;
  MultipartResGroupFeatures if t == GROUP_FEATURES;
  MultipartResMeters        if t == METER;
  MultipartResMeterConfigs  if t == METER_CONFIG;
  MultipartResMeterFeatures if t == METER_FEATURES;
  MultipartResTableFeatures if t == TABLE_FEATURES;
  MultipartResExperimenter  if t == EXPERIMENTER;
}

def MultipartRes : type = record {
  type    : MultipartType;
  flags   : nat(16,msbf);
  payload : MultipartResPayload;
}

def BarrierReq : type = record {}
def BarrierRes : type = record {}

def QueueGetConfigReq : type = record {
  port : PortID;
       : nat(32);
}

def Property : type = enum(nat(16,msbf)) {	
  MIN_RATE     = 1,
  MAX_RATE     = 2,
  EXPERIMENTER = 65535
}

def QueuePropertyMinRate : type = record {
  rate : nat(16,msbf);
       : nat(48,msbf);
}

def QueuePropertyMaxRate : type = record {
  rate : nat(16,msbf);
       : nat(48,msbf);
}

def QueuePropertyExperimenter : type = record {
  experimenter : nat(32,msbf);
               : nat(32);
  data         : vector(nat(8));
}

def QueueProperyPayload(t:Property):type = variant {
  QueuePropertyMinRate      if t == MIN_RATE;
  QueuePropertyMaxRate      if t == MAX_RATE;
  QueuePropertyExperimenter if t == EXPERIMENTER;
}

def QueueProperty : type = record {
  property : Property;
  length   : nat(16,msbf);
           : nat(32,msbf);
  payload  : QueueProperyPayload;
  
  restrict(length - 8, payload);
}

def Queue : type = record {
  queue_id   : nat(32,msbf);
  length     : nat(16,msbf);
             : nat(16,msbf);
  properties : vector(QueueProperty);

  restrict(length - 8, properties);  
}

def QueueGetConfigRes : type = record {
  port   : PortID;
         : nat(32);
  queues : vector(Queue);	   
}

def RoleReq : type = record {}

def Role : type = enum(nat(64,msbf)) {	
  NO_CHANGE = 0,
  EQUAL     = 1,
  MASTER    = 2,
  SLAVE     = 3
}

def RoleRes : type = record {
  role          : Role;
                : nat(32);
  generation_id : nat(64,msbf);  	   
}

def GetAsyncReq : type = record {}

def PacketInMask : type = enum(nat(32,msbf)) {	
  0..7,
  NO_MATCH    = 1,
  ACTION      = 2,
  INVALID_TTL = 4
}

def PortStatusMask : type = enum(nat(32,msbf)) {	
  0..7,
  ADD    = 1,
  DELETE = 2,
  MODIFY = 4
}

def FlowRemovedMask : type = enum(nat(32,msbf)) {	
  IDLE_TIMEOUT = 1,
  HARD_TIMEOUT = 2,
  DELETE       = 3,
  GROUP_DELETE = 4
}
  
def GetAsyncRes : type = record {
  packet_in_mask          : PacketInMask;
  packet_in_mask_slave    : PacketInMask;
  port_status_mask        : PortStatusMask;
  port_status_mask_slave  : PortStatusMask;
  flow_removed_mask       : FlowRemovedMask;
  flow_removed_mask_slave : FlowRemovedMask;
}

def SetAsync : type = record {
  packet_in_mask          : PacketInMask;
  packet_in_mask_slave    : PacketInMask;
  port_status_mask        : PortStatusMask;
  port_status_mask_slave  : PortStatusMask;
  flow_removed_mask       : FlowRemovedMask;
  flow_removed_mask_slave : FlowRemovedMask;
}

def MeterModCommand : type = enum(nat(16,msbf)) {	
  ADD    = 0,
  DELETE = 1,
  MODIFY = 2
}

def MeterId : type = enum(nat(32,msbf)) {	
  0..4294901760,
  SLOW_DATAPATH = 4294967263,
  CONTROLLER    = 4294967264,
  ALL           = 4294967265
}

def MeterBand : type = record {
  type       : MeterBandType;
  len        : nat(16,msbf); 
  rate       : nat(32,msbf); 
  burst_size : nat(32,msbf); 
             : nat(32);
}

def MeterMod : type = record {
  command     : MeterModCommand;
  flags       : MeterFlags;
  meter_id    : MeterId;
  meter_bands : vector(MeterBand);
}

def Payload(t:Type):type = variant {
  Hello             if t == HELLO;
  Error             if t == ERROR;
  EchoReq           if t == ECHO_REQ;
  EchoRes           if t == ECHO_RES;
  Experimenter      if t == EXPERIMENTER;
  FeatureReq        if t == FEATURE_REQ;
  FeatureRes        if t == FEATURE_RES;
  GetConfigReq      if t == GET_CONFIG_REQ;
  GetConfigRes      if t == GET_CONFIG_RES;
  SetConfig         if t == SET_CONFIG;
  PacketIn          if t == PACKET_IN;
  FlowRemoved       if t == FLOW_REMOVED;
  PortStatus        if t == PORT_STATUS;
  PacketOut         if t == PACKET_OUT;
  FlowMod           if t == FLOW_MOD;
  GroupMod          if t == GROUP_MOD;
  PortMod           if t == PORT_MOD;
  TableMod          if t == TABLE_MOD;
  MultipartReq      if t == MULTIPART_REQ;
  MultipartRes      if t == MULTIPART_RES;
  BarrierReq        if t == BARRIER_REQ;
  BarrierRes        if t == BARRIER_RES;
  QueueGetConfigReq if t == QUEUE_GET_CONFIG_REQ;
  QueueGetConfigRes if t == QUEUE_GET_CONFIG_RES;
  RoleReq           if t == ROLE_REQ;
  RoleRes           if t == ROLE_RES;
  GetAsyncReq       if t == GET_ASYNC_REQ;
  GetAsyncRes       if t == GET_ASYNC_RES;
  SetAsync          if t == SET_ASYNC;
  MeterMod          if t == METER_MOD;
}

def Message : type = record {
  version : Version;
  type    : Type;
  length  : nat(16,msbf);
  xid     : nat(32,msbf);
  payload : Payload;

  restrict(length - 8, payload); 
}

} // v1_3 namspace
} // ofp namespace 